{
  "name": "stepper",
  "type": "registry:ui",
  "description": "A stepper component",
  "files": [
    {
      "type": "registry:ui",
      "content": "import { cn } from \"@/lib/utils\"\nimport { createContext, forwardRef, useContext, useRef, useState } from \"react\"\n\ninterface StepperFieldProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  start?: number\n  min?: number\n  max?: number\n  step?: number\n  shift?: number\n  className?: string\n  children?: React.ReactNode\n}\n\nexport const StepperField = forwardRef<HTMLDivElement, StepperFieldProps>(\n  ({ start, min, max, step, shift, children, className, ...props }, ref) => {\n    const inputRef = useRef<HTMLInputElement | null>(null)\n\n    // Handles focus when users click the field's chrome but not necessarily the input\n    const handleFocus = (e: React.PointerEvent<HTMLInputElement>) => {\n      if (e.screenX !== 0 && e.screenY !== 0) {\n        inputRef.current && inputRef.current.focus()\n        // Don't prevent default if the user is clicking on the input, as that may mess with\n        // things like highlighting text within the input\n        if (!(e.target as HTMLInputElement).matches(\"input\")) e.preventDefault()\n      }\n    }\n\n    return (\n      <StepperFieldContextProvider\n        min={min}\n        max={max}\n        start={start}\n        step={step}\n        shift={shift}\n        inputRef={inputRef}\n      >\n        <div\n          onPointerDown={handleFocus}\n          className={cn(\n            \"has-[:focus]:inner-border-primary has-[:focus]:inner-border-2 hover:inner-border-2 inner-border group relative flex select-none flex-row items-center justify-center rounded-md px-1 py-1 text-xs hover:cursor-pointer\",\n            className,\n          )}\n          {...props}\n          ref={ref}\n        >\n          {children}\n        </div>\n      </StepperFieldContextProvider>\n    )\n  },\n)\nStepperField.displayName = \"StepperField\"\n\ninterface StepperFieldLabelProps\n  extends React.ComponentPropsWithoutRef<\"label\"> {\n  htmlFor: string\n  className?: string\n  children?: React.ReactNode\n}\n\nexport const StepperFieldLabel = forwardRef<\n  HTMLLabelElement,\n  StepperFieldLabelProps\n>(({ htmlFor, className, children, ...props }, ref) => {\n  return (\n    <label\n      htmlFor={htmlFor}\n      className={cn(\"mr-1 cursor-pointer border-r px-2 text-sm\", className)}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </label>\n  )\n})\nStepperFieldLabel.displayName = \"StepperFieldLabel\"\n\ninterface StepperFieldInputProps\n  extends React.ComponentPropsWithoutRef<\"input\"> {\n  id: string\n  className?: string\n}\n\nexport const StepperFieldInput = forwardRef<\n  HTMLInputElement,\n  StepperFieldInputProps\n>(({ className, ...props }, ref) => {\n  const { min, max, value, handleChange, handleKeyDown, handleBlur, inputRef } =\n    useStepperFieldContext()\n\n  const computedRef = ref ? ref : inputRef\n\n  return (\n    <input\n      type=\"number\"\n      value={value}\n      ref={computedRef}\n      min={min}\n      max={max}\n      onKeyDown={handleKeyDown}\n      onChange={handleChange}\n      onBlur={handleBlur}\n      style={{ width: String(value).length + \"ch\", ...props.style }}\n      className={cn(\n        \"min-w-4 cursor-pointer text-center text-sm [appearance:textfield] focus:border-0 focus:outline-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none\",\n        className,\n      )}\n      role=\"spinbutton\"\n      aria-valuenow={value ? value : undefined}\n      aria-valuemin={min ? min : undefined}\n      aria-valuemax={max ? max : undefined}\n      {...props}\n    />\n  )\n})\nStepperFieldInput.displayName = \"StepperFieldInput\"\n\ninterface StepperFieldButtonProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  direction: string\n  className?: string\n  children: any\n}\n\nexport const StepperFieldButton = forwardRef<\n  HTMLButtonElement,\n  StepperFieldButtonProps\n>(({ direction, className, children, ...props }, ref) => {\n  const { min, max, value, handleStep } = useStepperFieldContext()\n  const handleClick = (e: React.PointerEvent<HTMLButtonElement>): void => {\n    const shiftKeyHeld = e.shiftKey\n    handleStep(direction, shiftKeyHeld)\n    e.preventDefault()\n  }\n\n  const isDisabled = () => {\n    if (direction === \"down\" && (min || min === 0) && +value <= min) {\n      return true\n    } else if (direction === \"up\" && max && +value >= max) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  const divClass = cn(\n    \"group mx-0.5 flex h-6 w-6 items-center justify-center rounded-md\",\n    isDisabled() && \"opacity-40\",\n    !isDisabled() && \"hover:bg-accent hover:cursor-pointer\",\n    className,\n  )\n\n  return (\n    <button\n      onPointerDown={handleClick}\n      className={divClass}\n      /*\n      \"text field is usually the only focusable component because the increase and decrease functions are keyboard accessible via arrow keys\"\n      https://www.w3.org/WAI/ARIA/apg/patterns/spinbutton/\n      */\n      tabIndex={-1}\n      ref={ref}\n      {...props}\n    >\n      {children}\n    </button>\n  )\n})\nStepperFieldButton.displayName = \"StepperFieldButton\"\n\ninterface StepperFieldBadgeProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  hideWhen?: number\n  className?: string\n}\n\nexport const StepperFieldBadge = forwardRef<\n  HTMLDivElement,\n  StepperFieldBadgeProps\n>(({ hideWhen = 0, className, ...props }, ref) => {\n  const { value } = useStepperFieldContext()\n  if (value == hideWhen) return\n\n  return (\n    <div\n      className={cn(\n        \"bg-primary text-background text-2xs absolute -right-2.5 -top-2 rounded-full px-1.5 py-0 font-medium group-has-[:focus]:hidden\",\n        className,\n      )}\n      {...props}\n    >\n      {value}\n    </div>\n  )\n})\nStepperFieldBadge.displayName = \"StepperFieldBadge\"\ninterface StepperFieldContextType {\n  value: number | \"\"\n  handleStep: (direction: string, shiftStep?: boolean) => void\n  handleChange?: (e: React.ChangeEvent<HTMLInputElement>) => void\n  handleKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void\n  handleBlur?: (e: React.FocusEvent<HTMLInputElement>) => void\n  min?: number\n  max?: number\n  start?: number\n  inputRef?: React.RefObject<HTMLInputElement>\n}\n\nconst StepperFieldContext = createContext<StepperFieldContextType>({\n  value: 0,\n  handleStep: () => {},\n})\n\nconst useStepperFieldContext = () => {\n  const context = useContext(StepperFieldContext)\n\n  if (!context) {\n    throw new Error(\n      \"useStepperFieldContext must be used within a StepperFieldContextProvider\",\n    )\n  }\n\n  return context\n}\n\ninterface StepperFieldContextProviderProps {\n  min?: number\n  max?: number\n  start?: number\n  step?: number\n  shift?: number\n  inputRef: React.RefObject<HTMLInputElement>\n  children: React.ReactElement\n}\n\nconst StepperFieldContextProvider = ({\n  min,\n  max,\n  start = 0,\n  step = 1,\n  shift,\n  inputRef,\n  children,\n}: StepperFieldContextProviderProps) => {\n  const [value, setValue] = useState<number | \"\">(start)\n\n  const handleStep = (direction: string, shiftStep?: boolean) => {\n    let newValue: number\n    if (direction === \"up\") {\n      newValue = shiftStep && shift ? +value + shift : +value + step\n      setValueWithinRange(newValue)\n    } else if (direction === \"down\") {\n      newValue = shiftStep && shift ? +value - shift : +value - step\n      setValueWithinRange(newValue)\n    }\n  }\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.value === \"\") return setValue(\"\")\n    const newValue = +e.target.value\n    !isNaN(newValue) && setValueWithinRange(newValue)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const shiftKeyHeld = e.shiftKey\n    // User is using arrow keys to step, and may or may not be holding shift key\n    if (e.code == \"ArrowDown\" || e.code == \"ArrowUp\") {\n      const stepDirection = e.code === \"ArrowUp\" ? \"up\" : \"down\"\n      handleStep(stepDirection, shiftKeyHeld)\n      e.preventDefault()\n    }\n    // User is using page up or page down to step\n    else if (e.code == \"PageUp\") {\n      handleStep(\"up\", true)\n      e.preventDefault()\n    } else if (e.code == \"PageDown\") {\n      handleStep(\"down\", true)\n      e.preventDefault()\n    }\n    // User is pressing home or end within the stepper field\n    else if (e.code == \"Home\") {\n      setValueToMin()\n      e.preventDefault()\n    } else if (e.code == \"End\") {\n      setValueToMax()\n      e.preventDefault()\n    }\n    // User is pressing enter within the stepper field\n    else if (e.code == \"Enter\") {\n      setValueWithinRange(value)\n      e.preventDefault()\n    }\n    return\n  }\n\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    setValueWithinRange(+e.target.value)\n  }\n\n  const setValueToStart = () => {\n    setValue(start)\n  }\n\n  const setValueToMax = () => {\n    if (typeof max === \"number\") setValue(max)\n  }\n\n  const setValueToMin = () => {\n    if (typeof min === \"number\") setValue(min)\n  }\n\n  const setValueWithinRange = (value: number | \"\") => {\n    if (!value) return setValueToStart()\n    if (isBelowMin(value)) return setValueToMin()\n    if (isAboveMax(value)) return setValueToMax()\n\n    return setValue(value)\n  }\n\n  const isBelowMin = (value: number) => {\n    return (min || min === 0) && value < min\n  }\n\n  const isAboveMax = (value: number) => {\n    return max && value > max\n  }\n\n  return (\n    <StepperFieldContext.Provider\n      value={{\n        value,\n        handleStep,\n        handleChange,\n        handleKeyDown,\n        handleBlur,\n        min,\n        max,\n        start,\n        inputRef,\n      }}\n    >\n      {children}\n    </StepperFieldContext.Provider>\n  )\n}\n",
      "path": "ui/stepper.tsx",
      "target": "components/ui/stepper.tsx"
    }
  ]
}