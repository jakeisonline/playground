{
  "name": "segmented-control",
  "type": "registry:ui",
  "description": "A segmented control component",
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\"\n\nimport {\n  SegmentedControlContextProvider,\n  useSegmentedControl,\n} from \"@/hooks/use-segmented-control\"\nimport { cn } from \"@/lib/utils\"\nimport React, { useEffect, useRef } from \"react\"\n\ntype SegmentedControlProps = {\n  defaultValue: string\n  children: React.ReactNode\n  className?: string\n  role?: string\n}\n\nexport const SegmentedControl = ({\n  defaultValue,\n  children,\n  className,\n  role,\n  ...props\n}: SegmentedControlProps) => {\n  const stuffedProps = { ...props, defaultValue, className, role }\n\n  return (\n    <SegmentedControlContextProvider defaultValue={defaultValue}>\n      <SegmentedControlMapper {...stuffedProps}>\n        {children}\n      </SegmentedControlMapper>\n    </SegmentedControlContextProvider>\n  )\n}\nSegmentedControl.displayName = \"SegmentedControl\"\n\ninterface SegmentedControlMapperProps {\n  children: React.ReactNode\n  className?: string\n  role?: string\n}\n\nconst SegmentedControlMapper = ({\n  children,\n  className,\n  role,\n  ...props\n}: SegmentedControlMapperProps) => {\n  const { setValues } = useSegmentedControl()\n  const controlValues: string[] = []\n\n  React.Children.forEach(children, (child) => {\n    if (React.isValidElement(child) && child.props.value) {\n      controlValues.push(child.props.value)\n    }\n\n    setValues(controlValues)\n  })\n\n  return (\n    <div\n      className={cn(\n        \"flex gap-1 rounded-md bg-accent p-1 shadow-inner\",\n        className,\n      )}\n      role={role || \"radiogroup\"}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\ninterface SegmentedControlItemProps\n  extends React.ComponentPropsWithoutRef<\"button\"> {\n  value: string\n  children: React.ReactNode\n  disabled?: boolean\n  className?: string\n  role?: string\n  ariaChecked?: boolean\n}\n\nexport const SegmentedControlItem = ({\n  value,\n  children,\n  className,\n  disabled,\n  role,\n  ...props\n}: SegmentedControlItemProps) => {\n  const { selectControlItem, selectedValue, selectNextControlItem } =\n    useSegmentedControl()\n  const selfRef = useRef<HTMLButtonElement>(null)\n  const isSelected = selectedValue === value\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    if (disabled) return\n    selectControlItem(value)\n    e.currentTarget.dataset.state = \"active\"\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLButtonElement>) => {\n    if (e.key === \"ArrowRight\") selectNextControlItem(\"next\")\n    if (e.key === \"ArrowLeft\") selectNextControlItem(\"previous\")\n  }\n\n  useEffect(() => {\n    if (isSelected) {\n      selfRef.current?.focus()\n    }\n  }, [isSelected])\n\n  return (\n    <button\n      aria-disabled={disabled}\n      aria-checked={isSelected}\n      aria-selected={isSelected}\n      className={cn(\n        \"rounded-sm bg-accent px-4 py-1 text-muted-foreground transition-colors duration-300 focus:outline-primary disabled:cursor-not-allowed data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow\",\n        className,\n      )}\n      data-state={isSelected ? \"active\" : \"inactive\"}\n      disabled={disabled}\n      role={role || \"radio\"}\n      onClick={handleClick}\n      onKeyDown={handleKeyDown}\n      tabIndex={isSelected ? 0 : -1}\n      value={value}\n      ref={selfRef}\n      {...props}\n    >\n      {children}\n    </button>\n  )\n}\nSegmentedControlItem.displayName = \"SegmentedControlItem\"\n",
      "path": "ui/segmented-control.tsx",
      "target": "components/ui/segmented-control.tsx"
    },
    {
      "type": "registry:hook",
      "content": "import { createContext, useContext, useRef, useState } from \"react\"\n\nexport const useSegmentedControl = () => {\n  const context = useContext(SegmentedControlContext)\n\n  if (!context) {\n    throw new Error(\n      \"useSegmentedControl must be used within a SegmentedControlContextProvider\",\n    )\n  }\n\n  return context\n}\n\ntype SegmentedControlContextType = {\n  selectedValue: string | null\n  selectControlItem: (value: string) => void\n  setValues: (value: string[]) => void\n  selectNextControlItem: (direction: \"next\" | \"previous\") => void\n}\n\nexport const SegmentedControlContext =\n  createContext<SegmentedControlContextType>({\n    selectedValue: null,\n    selectControlItem: () => {},\n    setValues: () => {},\n    selectNextControlItem: () => {},\n  })\n\ntype SegmentedControlContextProviderProps = {\n  defaultValue: string\n  children: React.ReactNode\n}\n\nexport const SegmentedControlContextProvider = ({\n  defaultValue,\n  children,\n}: SegmentedControlContextProviderProps) => {\n  const [selectedValue, setSelectedValue] = useState<string>(defaultValue)\n  const values = useRef<string[]>([])\n\n  const setValues = (value: string[]) => {\n    values.current = value\n  }\n\n  const selectControlItem = (value: string) => {\n    setSelectedValue(value)\n  }\n\n  const selectNextControlItem = (direction: \"next\" | \"previous\") => {\n    const currentIndex = values.current.indexOf(selectedValue)\n    const nextIndex =\n      direction === \"next\"\n        ? (currentIndex + 1) % values.current.length\n        : (currentIndex - 1 + values.current.length) % values.current.length\n    setSelectedValue(values.current[nextIndex])\n  }\n\n  return (\n    <SegmentedControlContext.Provider\n      value={{\n        selectedValue,\n        selectControlItem,\n        setValues,\n        selectNextControlItem,\n      }}\n    >\n      {children}\n    </SegmentedControlContext.Provider>\n  )\n}\n",
      "path": "hooks/use-segmented-control.tsx",
      "target": "hooks/use-segmented-control.tsx"
    }
  ]
}